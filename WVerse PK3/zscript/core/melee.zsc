//------------------------------------------------------------------------------
// Taken and modified from The Space Pirate, code by DrPyspy
//------------------------------------------------------------------------------

Class WVerse_Weapon_Core : DoomWeapon
{
	int wv_curclip;
	int wv_clipsize;
	
	Property ClipSize : wv_clipsize;
	
	Default
	{
		WVerse_Weapon_Core.ClipSize 16;
	}
	
	bool canReload()
	{
		return ( owner.CountInv(ammo1.GetClass()) > 0 );
	}
	
	/*
	==========================================================================
	A_WVerse_CheckReload
		
	Returns:
		Nothing technically. It just jumps to the reload state.
	==========================================================================
	*/
	
	action state A_WVerse_CheckReload()
	{
		if ( wv_curclip < invoker.ammouse1 )
		{
			if ( canReload() )
			{
				return resolveState("Reload");
			}
		}
		return resolveState(null);
	}
	
	/*
	==========================================================================
	A_WVerse_ReloadAmmo
		
	Parameters:
		amt (int)
			Amount of ammo to reload when this action is called. Anything below 1 will reload as much as possible in one call, like when you're chuckin' a clip into the gun.
	==========================================================================
	*/
	
	action void A_WVerse_ReloadAmmo(int amt = 0)
	{
		bool chuckItIn = ( amt < 1 );
		while ( ( chuckItIn || amt > 0 ) invoker.wv_curclip < invoker.GetClipCapacity() && invoker.canReload() )
		{
			amt--;
			invoker.wv_curclip++;
			invoker.owner.TakeInventory(invoker.ammo1.GetClass(), 1);
		}
	}
	
	/*
	==========================================================================
	A_WVerse_Melee
		
	Parameters:
		mDamage (int)
			Damage dealt to foes
		mRange (int)
			Affective range of melee
		mPuff (string)
			Bullet puff to use when hitting a wall OR nobody is hit
		flags (int)
			yuh
		mStunTime (int)
			How long to stun fellas for (also used for pausing the weapon animation)
		mMaxAngle (int)
			Enemies within this angle are hit
		mMaxPitch (int)
			does nothing atm LMAo fuck u!!!
	==========================================================================
	*/
	
	action bool A_WVerse_Melee(int mDamage, int mRange = 72, string mPuff = "BulletPuff", int flags = 0, int mStunTime = 5, int mMaxAngle = 45, int mMaxPitch = 45)
	{
		bool hasHit;
		bool hasKilled;
		
		Array<Actor> hit_fellas;
		hit_fellas.clear();
		Array<Actor> freeze_fellas;
		freeze_fellas.clear();
		
		BlockThingsIterator get_fellas = BlockThingsIterator.Create(self, mRange, 0);
		
		Actor mo;
		
		Class<Actor > bulletPuffToSpawn = mPuff;
		
		while ( get_fellas.Next() )
		{
			mo = Actor(get_fellas.thing);
			
			if ( mo == invoker.owner ) continue;
			
			if ( invoker.owner.Distance3D(mo) - mo.radius < mRange 
				&& ( mo.bShootable )
				&& mo.Health > 0
				&& !mo.bNoDamage
				&& CheckSight(mo)
				&& abs(DeltaAngle(AngleTo(mo), self.angle)) < mMaxAngle )
			{
				int damager = mo.DamageMobj(invoker.owner, invoker.owner, mDamage, 'Melee', DMG_THRUSTLESS);
				
				if( !mo.bNoPain && mo.resolveState("Pain") != null && mo.Health > 0 )
				{
					mo.SetStateLabel("Pain"); //keep an eye on this conflicting with the freeze code
				}
				mo.A_SetTics(mo.tics + mStunTime);
				
				if( !mo.bNoBlood )
				{
					for ( int i = 0; i<3; i++ )
					{
						Actor blood = mo.Spawn(mo.BloodType, mo.pos+(0,0,mo.Height/2));
						blood.vel = (frandom(-2,2),frandom(-2,2),frandom(2,6));
					}
				}
				mo.A_PlaySound(bulletPuffToSpawn.SpawnSound, CHAN_BODY);
				
				if ( mo.Health <= 0 )
				{
					hasKilled = true;
				}
				
				hit_fellas.Push(mo);
			}
		}
		
		if ( hit_fellas.Size() > 0 )
		{
			hasHit = true;
			A_SetTics(mStunTime);
		
			for ( int i = 0; i < freeze_fellas.Size(); i++ )
			{
				freeze_fellas[i].A_SetTics(freeze_fellas[i].tics + mStunTime);
				if ( freeze_fellas[i].bIsMonster )
				{
					freeze_fellas[i].ReactionTime += mStunTime;
				}
			}
		}
		else
		{
			A_FireBullets(0, 0, 1, 0, mPuff, 0, mRange);
		}
			
		if ( hasKilled )
		{
			invoker.owner.A_StartSound("misc/meleekill", CHAN_BODY, CHANF_OVERLAP);
		}
		
		return hasHit;
	}
}